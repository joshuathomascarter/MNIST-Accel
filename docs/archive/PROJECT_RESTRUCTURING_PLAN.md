# ACCEL-v1 Restructuring & Migration Plan
**Date:** December 1, 2025
**Target:** Full AXI4-Based Sparse Accelerator System

## 1. Executive Summary
The current codebase is in a "hybrid" state between the old UART-based prototype (`top_sparse.sv`) and the new AXI-based system (`accel_top.sv`). 

**The Goal:** Consolidate everything into `accel_top.sv`, remove all UART legacy code, and implement the "Dual DMA" architecture (Weights + Activations) connected via a Read Arbiter Bridge.

**Estimated Time to Completion:** 5-7 Days (assuming 3-4 hours/day).

---

## 2. File-by-File Deep Analysis

### A. `rtl/top/accel_top.sv` (The Critical Path)
*   **Current State:** Messy. It contains:
    *   Legacy UART Command Decoder (Lines 150-300).
    *   Legacy UART TX Logic (Lines 350-400).
    *   A "Write-Mode" Bridge instantiation (Lines 450-480).
    *   Both Dense and Sparse Systolic Arrays instantiated (confusing).
*   **Required Changes:**
    1.  **Delete UART:** Remove `uart_rx`, `uart_tx`, `cmd_decoder`, and all associated state machines.
    2.  **Instantiate `act_dma`:** Add the new Activation DMA module.
    3.  **Update Bridge Connection:** Change the bridge connection from "Write Buffers" to "Read Request Arbiter".
    4.  **Fix `bsr_dma`:** Remove `uart_rx_data` connections; connect purely to CSRs and Bridge.
    5.  **Select Compute Core:** Decide if this is a "Sparse Only" or "Hybrid" chip. Recommendation: Comment out the Dense Systolic Array to save area and focus on the Sparse implementation.

### B. `rtl/top/top_sparse.sv`
*   **Current State:** This is the "Old Working Prototype". It uses `dma_lite` (UART-based).
*   **Action:** **DEPRECATE.** Do not edit this file. Use it only as a reference for how `bsr_scheduler` and `systolic_array_sparse` should be wired together.
*   **Migration:** Move the `meta_decode` -> `bsr_scheduler` -> `systolic_array_sparse` wiring logic into `accel_top.sv`.

### C. `rtl/monitor/perf.sv`
*   **Current State:** Good. Standard counter logic.
*   **Required Changes:** Minimal.
    *   Ensure `busy_signal` is an OR of (`act_dma.busy`, `bsr_dma.busy`, `scheduler.busy`).
    *   Ensure `start_pulse` captures the AXI-Lite start signal.

### D. `rtl/control/multi_layer_buffer.sv`
*   **Current State:** Functional partitioned BRAM.
*   **Required Changes:** None immediately.
    *   *Future Optimization:* If the host needs to write to this directly via AXI, we might need to map it to the AXI-Lite Slave address space, but for now, let the Scheduler manage it.

### E. `rtl/control/block_reorder_buffer.sv`
*   **Current State:** Functional Insertion Sort.
*   **Required Changes:** None. This module is self-contained.

---

## 3. The Restructuring Roadmap (5-7 Days)

### **Phase 1: The Foundation (Dec 2 - Dec 3)**
*   **Focus:** Control Plane & Data Movement.
*   **Tasks:**
    1.  **`csr.sv` & `axi_lite_slave_v2.sv`:** Add registers for `ACT_DMA`.
    2.  **`act_dma.sv`:** Create the module (Linear AXI Reader).
    3.  **`axi_dma_bridge.sv`:** **REWRITE.** Convert from "Write Slave" to "Read Arbiter" (2 Masters -> 1 DDR Port).

### **Phase 2: The Top-Level Cleanup (Dec 4 - Dec 5)**
*   **Focus:** `accel_top.sv` Surgery.
*   **Tasks:**
    1.  **Purge:** Delete all UART code from `accel_top.sv`.
    2.  **Wiring:** Connect `act_dma` and `bsr_dma` to the new Bridge.
    3.  **Buffers:** Connect DMAs to `act_buffer` and `wgt_buffer` (Write Ports).
    4.  **Compute:** Ensure `bsr_scheduler` is driving the `systolic_array_sparse`.

<<<<<<< HEAD
### **Phase 3: Verification & Closure (Dec 5 - Dec 7)**
=======
<<<<<<< HEAD
### **Phase 3: Verification & Closure (Dec 4 - Dec 5)**
=======
### **Phase 3: Verification & Closure (Dec 5 - Dec 7)**
>>>>>>> 60524f7 (Push all changes to GitHub)
>>>>>>> cb95bc6 (Push all changes except restructuring file)
*   **Focus:** Making it compile and run.
*   **Tasks:**
    1.  **Linting:** Fix signal width mismatches (common when ripping out UART).
    2.  **Testbench:** Update `accel_top_tb.sv` to drive AXI signals instead of UART bytes.
    3.  **Timing:** Check if the new Arbiter meets timing (50MHz should be easy, 200MHz might need pipelining).

---

## 4. The "Internship Quality" Add-Ons (Phase 4 & 5)

To reach NVIDIA/AMD standards, we need to go beyond just "working code".

<<<<<<< HEAD
### **Phase 4: The Compute Upgrade (Dec 8 - Dec 11)**
=======
<<<<<<< HEAD
### **Phase 4: The Compute Upgrade (Dec 6 - Dec 7)**
=======
### **Phase 4: The Compute Upgrade (Dec 8 - Dec 11)**
>>>>>>> 60524f7 (Push all changes to GitHub)
>>>>>>> cb95bc6 (Push all changes except restructuring file)
*   **`output_accumulator.sv` (New):**
    *   *Why:* Essential for Tiled Matrix Multiplication (ResNet-18). You need to add partial sums (`C = C + A*B`).
    *   *Action:* Create a module that reads current `C` from memory, adds the systolic result, and writes it back.
*   **Scaling to 8x8:**
    *   *Why:* 2x2 is a toy. 8x8 uses ~64 DSPs, which fits perfectly on the Zynq Z2 (220 DSPs available).
    *   *Action:* Change parameters in `accel_top.sv`.

<<<<<<< HEAD
### **Phase 5: The Software Stack (Dec 12 - Dec 14)**
=======
<<<<<<< HEAD
### **Phase 5: The Software Stack (Dec 8 - Dec 10)**
=======
### **Phase 5: The Software Stack (Dec 12 - Dec 14)**
>>>>>>> 60524f7 (Push all changes to GitHub)
>>>>>>> cb95bc6 (Push all changes except restructuring file)
*   **Python Drivers (PYNQ):**
    *   `accel.py`: The Class that talks to your CSRs.
    *   `memory.py`: Manages DDR buffers (CMA).
    *   `benchmark_sparse.py`: The script that proves your GOPS.
*   **Note:** Do not create `csr_sparse.sv` or `axi_lite_csr.sv`. We will stick to `csr.sv` and `axi_lite_slave_v2.sv` to keep it clean.

<<<<<<< HEAD
### **Phase 6: Verification & Coverage (Dec 15 - Dec 21)**
=======
<<<<<<< HEAD
### **Phase 6: Verification & Coverage (Dec 11 - Dec 23)**
=======
### **Phase 6: Verification & Coverage (Dec 15 - Dec 21)**
>>>>>>> 60524f7 (Push all changes to GitHub)
>>>>>>> cb95bc6 (Push all changes except restructuring file)
*   **Goal:** 90% Functional Coverage.
*   **Action:** Use Cocotb to randomize inputs and verify corner cases (empty matrices, full matrices, back-to-back runs).

## 6. Future Optimizations (The "Apple Polish")

### **Phase 7: Low Power Optimization (Fine-Grained Clock Gating)**
*   **Goal:** Reduce dynamic power by gating clocks to idle logic.
*   **Target Files:**
    1.  **`rtl/systolic/pe.sv`**:
        *   *Action:* Add a `clock_enable` signal to the MAC input registers. If the input data is zero (sparsity) or the PE is stalled, disable the clock to the multiplier.
    2.  **`rtl/mac/mac8.sv`**:
        *   *Action:* Gate the DSP slice clock if the inputs are invalid.
    3.  **`rtl/systolic/systolic_array_sparse.sv`**:
        *   *Action:* Generate column-wise or row-wise clock gating signals based on the sparsity map (e.g., if a whole column is zero, turn off the clock for that column of PEs).

## 7. Summary of Workload & Timeline
*   **Total Time:** ~3-4 Weeks to "Internship Ready".
*   **Critical Path:**
    1.  AXI Restructuring (The Bridge & DMA) - **Must be perfect.**
    2.  Python Driver - **Required to demo.**
    3.  ResNet-18 Layer Test - **The "Money Shot".**

**Verdict:** You are building a real SoC. This is the correct path. Stick to the schedule.
